[{"categories":["Articles"],"content":"How to Implement a recursive binary search algorithm in Swift.","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"Recursion is one very interesting subject in computer science. It is so interesting that the more you read about it, the more intrigued you become, and would like to learn more about the concept behind it. ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:0:0","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"What is recursion in computer science? Recursion is a concept of calling a function or method within itself (without a loop) over and over again until a certain condition is met, and that condition is called the kill switch or base case. ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:1:0","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"The kill switch The kill switch is very important in a recursive function just like how a switch is important for a light bulb because without a switch the light bulb will continue to light until it eventually dies, and without a kill switch for a recursive function it will run into an infinity loop and continues until your computer memory gets overflowed, and you wouldn’t want that. ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:1:1","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"Recursive function example The example below is a simple recursive function that accepts a value n then calculates and return the factorial of that value n using the factorial formula: Recursive formula $$n! = n\\sdot(n - 1)! \\ when \\enspace n \\eqslantgtr 1$$ func factorial(of n: Int) -\u003e Int { if n \u003c= 1 { return 1 } else { return n * factorial(of: n - 1) } } Kill switch Kill Switch/Base case if n \u003c= 1 { return 1 } The n \u003c= 1 is our kill Switch, the factorial of both 1 and 0 is 1 and there is no reason to call the function body again. If we didn’t implement the kill switch the function will keep calling itself forever even when n is no longer positive and this already defies the formula rule which states that n must be greater than 1. ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:1:2","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"Recursive binary search In this example, I will show you how to implement a binary search function using the recursion method (there will be no loops involved). Binary search Before We proceed if you don’t understand how binary algorithm works I suggest you take a look at the previous post on binary search here ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:2:0","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"1. Create function func recursiveBinarySearch(for value: Int, in items: [Int], left: Int, right: Int) -\u003e Int? { var mid = (left + right) / 2 } What we have just done above is pass the variables that will be used to calculate the middle of array to the function itself since we no longer have a loop to help us update their values each time, just like usual. ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:2:1","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"2. Add a kill switch Now let’s add a kill switch so that our function will know when to stop looking for value i.e. calling itself. func recursiveBinarySearch(for value: Int, in items: [Int], left: Int, right: Int) -\u003e Int? { var mid = (left + right) / 2 if left \u003e right { return nil } } Our kill switch states that whenever the left is bigger than the Right it should stop looking for value and just return nil because our value was not found. ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:2:2","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"3. Return found value The second kill switch, the else if items[mid] == value this will make sure that the function stops calling itself again when our value is found and return it. func recursiveBinarySearch(for value: Int, in items: [Int], left: Int, right: Int) -\u003e Int? { var mid = (left + right) / 2 if left \u003e right { return nil } else if items[mid] == value { return mid } } ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:2:3","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"4. Recursive call Now let us add the complete body in charge of calling the functions for updating left and right for recalculation of middle func recursiveBinarySearch(for value: Int, in items: [Int], left: Int, right: Int) -\u003e Int? { var mid = (left + right) / 2 if left \u003e right { return nil } else if items[mid] == value { return mid } else if items[mid] \u003c value { return recursiveBinarySearch(for: value, in: items, left: mid + 1, right: right) } else { return recursiveBinarySearch(for: value, in: items, left: left, right: mid - 1) } } ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:2:4","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"Testing the binary search function let numbers = [-2, 0, 1, 4, 10, 20, 30, 40, 50, 60, 70, 90] let value = 30 if let index = recursiveBinarySearch(for: value, in: numbers, left: 0, right: numbers.count - 1) { print(\"Index is : \\(index)for value: \\(numbers[index])\") } let valueTwo = -50 if let index = recursiveBinarySearch(for: valueTwo, in: numbers, left: 0, right: numbers.count - 1) { print(\"Index is : \\(index)for value: \\(numbers[index])\") } else { print(\"value: \\(valueTwo)is not in numbers\") } ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:2:5","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"Conclusion This marks the end of this tutorial on recursive binary search algorithm implementation in swift. Hope you had fun reading along, report any typos, or errors, and I will follow up. ","date":"2021-12-14","objectID":"/posts/implementing-recursive-binary-search-in-swift/:3:0","tags":["Swift","Algorithms"],"title":"Understanding and implementing recursive binary search in swift","uri":"/posts/implementing-recursive-binary-search-in-swift/"},{"categories":["Articles"],"content":"How to quickly reduce your swift array to a single value.","date":"2021-12-11","objectID":"/posts/how-to-sum-and-reduce-array-elements-in-swift/","tags":["Swift","Basic"],"title":"How to sum and reduce array elements in Swift","uri":"/posts/how-to-sum-and-reduce-array-elements-in-swift/"},{"categories":["Articles"],"content":"Sometimes you want to reduce (sum) the values of an array to a single final value in your swift code, this can easily be achieved by using the Array reduce method. ","date":"2021-12-11","objectID":"/posts/how-to-sum-and-reduce-array-elements-in-swift/:0:0","tags":["Swift","Basic"],"title":"How to sum and reduce array elements in Swift","uri":"/posts/how-to-sum-and-reduce-array-elements-in-swift/"},{"categories":["Articles"],"content":"Sum array of Integers let twenty20 = Array(repeating: 20, count: 20) let sum = twenty20.reduce(0, +) print(sum) Output:400 let myNumbers = [20, 50, 10, -1, 0, 500] let sum = myNumbers.reduce(0, +) ","date":"2021-12-11","objectID":"/posts/how-to-sum-and-reduce-array-elements-in-swift/:1:0","tags":["Swift","Basic"],"title":"How to sum and reduce array elements in Swift","uri":"/posts/how-to-sum-and-reduce-array-elements-in-swift/"},{"categories":["Articles"],"content":"Understanding and Implementing the merge sort algorithm recursively in Swift.","date":"2021-12-10","objectID":"/posts/implementing-recursive-merge-sort-in-swift/","tags":["Swift","Algorithms"],"title":"Implementing recursive merge sort in swift","uri":"/posts/implementing-recursive-merge-sort-in-swift/"},{"categories":["Articles"],"content":"What is a Mergesort algorithm? The mergesort algorithm is one of the popular and efficient divide and conquer algorithms in computer science, and it is used for sorting a list of items. While there are a few different mergesort algorithm functions, I will be discussing the top-down method in this article. ","date":"2021-12-10","objectID":"/posts/implementing-recursive-merge-sort-in-swift/:1:0","tags":["Swift","Algorithms"],"title":"Implementing recursive merge sort in swift","uri":"/posts/implementing-recursive-merge-sort-in-swift/"},{"categories":["Articles"],"content":"How it works Mergesort is a sorting algorithm that uses a divide and conquer method to sort a list, by recursively dividing the list into two equal sizes commonly named left and right and it continues to (apply the same logic) each side of the division until only one item is remaining. After the divisions it will then proceed to sort and merge each of the sides back together again. Example In this example I will be showing you how to implement a merge sort algorithm in Swift, we will be using the merge sort to sort a list of random numbers. Note From the illustration above and explanation of the algorithm, we can see that we have three important aspect of the merge sort, the splitting process, sorting process, and the merging process ","date":"2021-12-10","objectID":"/posts/implementing-recursive-merge-sort-in-swift/:1:1","tags":["Swift","Algorithms"],"title":"Implementing recursive merge sort in swift","uri":"/posts/implementing-recursive-merge-sort-in-swift/"},{"categories":["Articles"],"content":"MergeSort We are going to build and separate these machines (functions) away from each so that we can focus directly on what each machine needs to accomplish and build it. 1. Splitting process function This function will be in charge of splitting the items and returning a sorted version of the items. func mergeSort(for items: [Int]) -\u003e [Int] { var leftItems:[Int] var rightItems: [Int] var result: [Int] let length = items.count } State variables Below are the explanation to the new variable we have just introduced in the function. leftItems: We are using it to store the state of each left item of a division rightItems: We are also using it to store the state of each right division result: Use for storing the result of each sort and merge operation length: Used for tracking the size of each side of the division func mergeSort(for items: [Int]) -\u003e [Int] { var leftItems:[Int] var rightItems: [Int] var result: [Int] let length = items.count if length \u003c= 1 { result = items } } Base case Example if length \u003c= 1 { result = items } checks if the size of items (the list) is less than or equal to 1 return from the function and quit further splitting. Obviously there would be nothing else to split at this point. func mergeSort(for items: [Int]) -\u003e [Int] { var leftItems:[Int] var rightItems: [Int] var result: [Int] let length = items.count if length \u003c= 1 { result = items } else { leftItems = Array(items[0..\u003clength / 2]) rightItems = Array(items[(length / 2)..\u003clength]) result = merge(for: mergeSort(on: leftItems), and: mergeSort(on: rightItems)) } return result } Splitting the items list We added an else statement, this will be in charge of splitting the list whenever the (size) length is greater than 1 leftItems and rightItems: Here we are initializing the leftItems to contain an Array of half size of the items list whenever the function calls itself. result: The result, is initialized with result of calling the merge function that is in charge of sorting and merging each division of the items list. Though the merge function, is not yet implemented, and we will do that next. Tip Note that here we used the Swift Array subscript syntax to divide each list items and grab the half of it, instead of using a loop to iterate over the entire list items to grab the half of it. i.e. items[0..\u003c n/2] will produce half of the items 2. The merge function This function accepts and two different lists leftItems and rightItems which are the left and right sides of items list division. The function will now compute and return the result of sorting and merging each list items. func merge(for leftItems: [Int], and rightItems: [Int]) -\u003e [Int] { var result = [Int]() var rightPosition = 0 var leftPosition = 0 } result: This will be used to store the result of sorting each item. rightPosition and leftPosition: This is used to track the index of each list item starting from 0 func merge(for leftItems: [Int], and rightItems: [Int]) -\u003e [Int] { var result = [Int]() var rightPosition = 0 var leftPosition = 0 while (leftPosition \u003c leftItems.count || rightPosition \u003c rightItems.count) { // more to come } } Here we are checking for when either of the list size is greater than either of positions index. It makes sense to only do something whenever we have items with size greater than 1 Sorting and merging func merge(for leftItems: [Int], and rightItems: [Int]) -\u003e [Int] { var result = [Int]() var rightPosition = 0 var leftPosition = 0 while (leftPosition \u003c leftItems.count || rightPosition \u003c rightItems.count) { if (leftPosition \u003c leftItems.count \u0026\u0026 (rightPosition \u003e= rightItems.count || leftItems[leftPosition] \u003c= rightItems[rightPosition])) { result.append(leftItems[leftPosition]) leftPosition += 1 } } } Copying from leftItems Here we are copying from leftItems list only when the value in the leftItems list is smaller than the value in rightItems list (rightPosition \u003e= rightItems.count || leftItems[leftPosition] \u003c= rightItems[rightPosition]) or when there are no items left in ","date":"2021-12-10","objectID":"/posts/implementing-recursive-merge-sort-in-swift/:1:2","tags":["Swift","Algorithms"],"title":"Implementing recursive merge sort in swift","uri":"/posts/implementing-recursive-merge-sort-in-swift/"},{"categories":["Articles"],"content":"Testing the function var myList = [10, 5, 13, 12, 18, 38] let sortedList = mergeSort(on: myList) print(sortedList) Output: [5, 10, 12, 13, 18, 38] ","date":"2021-12-10","objectID":"/posts/implementing-recursive-merge-sort-in-swift/:2:0","tags":["Swift","Algorithms"],"title":"Implementing recursive merge sort in swift","uri":"/posts/implementing-recursive-merge-sort-in-swift/"},{"categories":["Articles"],"content":"How to find the index of array element in Swift.","date":"2021-12-01","objectID":"/posts/how-to-find-index-of-an-array-element-in-swift/","tags":["Swift","Basic"],"title":"How to find index of an array element in Swift","uri":"/posts/how-to-find-index-of-an-array-element-in-swift/"},{"categories":["Articles"],"content":"Swift standard library array is pack with lots of functionalities that help us mutate and perform operations on arrays, and some of these methods includes: ","date":"2021-12-01","objectID":"/posts/how-to-find-index-of-an-array-element-in-swift/:0:0","tags":["Swift","Basic"],"title":"How to find index of an array element in Swift","uri":"/posts/how-to-find-index-of-an-array-element-in-swift/"},{"categories":["Articles"],"content":"Methods firstIndex(where: ) firstIndex(of: ) first(where: ) ","date":"2021-12-01","objectID":"/posts/how-to-find-index-of-an-array-element-in-swift/:1:0","tags":["Swift","Basic"],"title":"How to find index of an array element in Swift","uri":"/posts/how-to-find-index-of-an-array-element-in-swift/"},{"categories":["Articles"],"content":"FirstIndex(where: ) The firstIndex(where: ) can be used to find and return the index of an array element and returns nil if the index is not found. let names = [\"Smith\", \"Kelvin\", \"Wendy\", \"Mike\"] if let index = names.firstIndex(where: {$0 == \"Wendy\"}) { print(index) } 2 ","date":"2021-12-01","objectID":"/posts/how-to-find-index-of-an-array-element-in-swift/:1:1","tags":["Swift","Basic"],"title":"How to find index of an array element in Swift","uri":"/posts/how-to-find-index-of-an-array-element-in-swift/"},{"categories":["Articles"],"content":"FirstIndex(of: ) Or we can also use the firstIndex(of: ) method if let index = names.firstIndex(of: \"Smith\") { print(\"index:\", index) } Index: 0 ","date":"2021-12-01","objectID":"/posts/how-to-find-index-of-an-array-element-in-swift/:1:2","tags":["Swift","Basic"],"title":"How to find index of an array element in Swift","uri":"/posts/how-to-find-index-of-an-array-element-in-swift/"},{"categories":["Articles"],"content":"First(where: ) To return the actual element instead of the index, we can use the first(where: ) method, this method also return an optional value the element or nil if not found. struct Rect: Identifiable { var id = UUID() var width: Double var height: Double func describe() -\u003e String { \"Width: \\(self.width), Height: \\(self.height)\" } } let rects = [ Rect(width: 25.0, height: 20.0), Rect(width: 125.0, height: 20.0), Rect(width: 25.0, height: 320.0) ] Using Rect type example. let rect = rects[2] if let rect = rects.first(where: {$0.height == rect.height}) { print(rect.describe()) } Width: 25.0, Height: 320.0 Find the rect index if let rect = rects.firstIndex(where: {$0.height == rect.height}) { print(rect) } 2 ","date":"2021-12-01","objectID":"/posts/how-to-find-index-of-an-array-element-in-swift/:1:3","tags":["Swift","Basic"],"title":"How to find index of an array element in Swift","uri":"/posts/how-to-find-index-of-an-array-element-in-swift/"},{"categories":["Articles"],"content":"How to quickly generate an array of any type in Swift.","date":"2021-12-01","objectID":"/posts/simple-swift-array-generator/","tags":["Swift","Basic"],"title":"How to quickly generate array in Swift","uri":"/posts/simple-swift-array-generator/"},{"categories":["Articles"],"content":"Sometimes you want to quickly generate an array in your swift code without having to manually type in the elements, you can quickly do that in Swift using the repeating method ","date":"2021-12-01","objectID":"/posts/simple-swift-array-generator/:0:0","tags":["Swift","Basic"],"title":"How to quickly generate array in Swift","uri":"/posts/simple-swift-array-generator/"},{"categories":["Articles"],"content":"Generate array of 20 zeros let twentyZeros = Array(repeating: 0, count: 20) print(twentyZeros) Output: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ","date":"2021-12-01","objectID":"/posts/simple-swift-array-generator/:1:0","tags":["Swift","Basic"],"title":"How to quickly generate array in Swift","uri":"/posts/simple-swift-array-generator/"},{"categories":["Articles"],"content":"Generating array of 50 strings let arrayOfString = Array(repeating: \"City\", count: 50) This same method can be applied to any type in swift such as objects, just provide whatever you want to generate, and specify the count. ","date":"2021-12-01","objectID":"/posts/simple-swift-array-generator/:2:0","tags":["Swift","Basic"],"title":"How to quickly generate array in Swift","uri":"/posts/simple-swift-array-generator/"},{"categories":["Articles"],"content":"How to Implement a binary search algorithm in Swift | a divider and conquer algorithm","date":"2021-12-01","objectID":"/posts/implementing-binary-search-in-swift/","tags":["Swift","Algorithms"],"title":"Understanding and implementing binary search in swift","uri":"/posts/implementing-binary-search-in-swift/"},{"categories":["Articles"],"content":"Binary search is a (divide and conquer) algorithm and one of the most popular and widely used algorithms for searching a data structure because of its efficiency and speed. I will be showing you how to implement a search algorithm using the binary search method, this method of searching is what is mostly used under the hood for Swift standard library API functions for searching items i.e. first(where: ) last(where: ) firstIndex(where: ) lastIndex(where: ) ","date":"2021-12-01","objectID":"/posts/implementing-binary-search-in-swift/:0:0","tags":["Swift","Algorithms"],"title":"Understanding and implementing binary search in swift","uri":"/posts/implementing-binary-search-in-swift/"},{"categories":["Articles"],"content":"The Problem Let’s say we have an array of 12 random numbers and would like to find 30 from this list of numbers, but you don’t know which index this favorite number of yours appears in the list. Question To solve this problem start by asking how many times do I have to look inside this array of numbers before I can find my favorite number? ","date":"2021-12-01","objectID":"/posts/implementing-binary-search-in-swift/:1:0","tags":["Swift","Algorithms"],"title":"Understanding and implementing binary search in swift","uri":"/posts/implementing-binary-search-in-swift/"},{"categories":["Articles"],"content":"First Approach Given that you know how to use loops to traverse an array and print its element, you would think to combine a for loop and if statement on the list of numbers to find and print any index whose value is your favorite number 30 your solution might look like the code below. let numbers = [20, 4, -2, 0, 1, 40, 50, 60, 10, 30, 90, 70] let myFavorite = 30 for (index, value) in numbers.enumerated() { if value == myFavorite { print(\"Index for favourite is: \", index) break } } Output: Index for favorite is: 9 Problem with this approach While this might put a smile on your face knowing that you have successfully found the index of your favorite number, and you only had to look 10 times But think what if this list of numbers is 10Billion in length, and your favorite number is at the very end of the list, woof! this would take 10Billion times to look inside the array of numbers, imagine if this was a person trying to individually look inside 10Billion boxes, that would take more than a lifetime to complete but of course computers are way faster than a human and would complete the task in a shorter amount of time compared to a human but longer than it took when the list was only 12 items. This will make you unhappy especially when you need your favorite number as soon as possible and don’t have time to wait for this 10Billion loop to complete. Good News! Good news is that a binary search algorithm can help reduce your wait time to a significant amount but only with one requirement from you. The list of numbers must be sorted (arranged in order). Binary search can only work on a list that is sorted, so it is a requirement that your list of numbers must be sorted. ","date":"2021-12-01","objectID":"/posts/implementing-binary-search-in-swift/:1:1","tags":["Swift","Algorithms"],"title":"Understanding and implementing binary search in swift","uri":"/posts/implementing-binary-search-in-swift/"},{"categories":["Articles"],"content":"Binary search Approach Start by asking yourself how many times do I have to divide 10Billion by 2 until the final answer is 0?. The solution is 34 times which is not too many and definitely not 10Billion times. 34 times is the worst case (The longest wait time) for a 10Billion list of numbers the maximum time we have to look inside the array to find our favorite number. How it works 1. Computed the middle index Binary search works by first taking the total length of the array and divides it into two parts commonly known as left and right where left represents the first index of the array which is 0 and right represents the last index of the array which is (n-1) or (numbers.count - 1). The outcome of this operation is called the middle and it represents the middle index of the array. let numbers = [-2, 0, 1, 4, 10, 20, 30, 40, 50, 60, 70, 90] //sorted var left = 0 var right = numbers.count - 1 var middle = (left + right) / 2 2. Search the array with middle The next step is to take the computed value of the middle which is 5 in this case and look inside the numbers list for our favorite number using the middle as the index value. 3. Update the middle If the value in the middle index corresponds to our favorite number we return it, and we are done but if not we will check if the value in the middle index is bigger than our favorite number (remember that our number is sorted) if yes then there is no need to look at any index below our current middle index, which mean we are only concerned with the indexes above our current middle index which it to the right and we have just saved ourselves the huddles of looking it 4 boxes that are to the left. Now that we have chosen NOT to look at the boxes below our middle index, we have to update the value of left because it is no longer 0 but now middle + 1 the reason why we are adding 1 to the middle is that we have already looked into it, and it doesn’t have our favorite number and there is no reason to include it again and vice versa. let myFavourite = 30 if numbers[middle] == myFavourite { print(\"Yes Found! Your favourite number at index: \\(middle)\\n\") } else if numbers[middle] \u003c myFavourite { print(\"The middle index \\(middle)with value: \\(numbers[middle])is too small\") print(\"Please update left to: \\(middle + 1)\\n\") } else { print(\"The middle index \\(middle)with value: \\(numbers[middle])is too large\") print(\"Please update right to: \\(middle - 1)\\n\") } Output: The middle index 5 with value: 20 is too small Please update left to: 6 4. Apply a loop You might be thinking that now is the best time to bring it the loop and perform these operations, again and again, until the favorite number index is found and yes you’re correct. Let’s perform these operations inside a loop and update the value of the middle index inside the loop each time to loop runs until the runs are completed. The diagram below shows the steps our algorithm is going to perform until the loop life cycle is completed or our favorite number is found. Diagram let numbers = [-2, 0, 1, 4, 10, 20, 30, 40, 50, 60, 70, 90] //sorted var left = 0 var right = numbers.count - 1 var middle = 0 while left \u003c= right { middle = (left + right) / 2 if numbers[middle] == myFavourite { print(\"Found! Your favourite number at index: \\(middle)with value: \\(numbers[middle])\\n\") break } else if numbers[middle] \u003c myFavourite { print(\"The middle index \\(middle)with value: \\(numbers[middle])is too small\") print(\"Please update left to: \\(middle + 1)\\n\") left = middle + 1 } else { print(\"The middle index \\(middle)with value: \\(numbers[middle])is too large\") print(\"Please update right to: \\(middle - 1)\\n\") right = middle - 1 } } Outputs: The middle index 5 with value: 20 is too small Please update left to: 6 The middle index 8 with value: 50 is too large Please update right to: 7 Found! Your favourite number at index: 6 with value: 30 Tip Notice that left is now 6 and right is 7 and mid is now (6 + 7) / 2 which is 6 (integer division), and 6 is the correc","date":"2021-12-01","objectID":"/posts/implementing-binary-search-in-swift/:1:2","tags":["Swift","Algorithms"],"title":"Understanding and implementing binary search in swift","uri":"/posts/implementing-binary-search-in-swift/"},{"categories":["Articles"],"content":"conclusion We have successfully built a binary search function that can be used to search a light of integers I hope you enjoyed the reading. Report any typos or questions, and I will follow up! ","date":"2021-12-01","objectID":"/posts/implementing-binary-search-in-swift/:2:0","tags":["Swift","Algorithms"],"title":"Understanding and implementing binary search in swift","uri":"/posts/implementing-binary-search-in-swift/"}]